{"version":3,"file":"animation_transition_expr.js","sourceRoot":"","sources":["../../../../../../../packages/animations/browser/src/dsl/animation_transition_expr.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const ANY_STATE = '*';\nexport declare type TransitionMatcherFn =\n    (fromState: any, toState: any, element: any, params: {[key: string]: any}) => boolean;\n\nexport function parseTransitionExpr(\n    transitionValue: string | TransitionMatcherFn, errors: string[]): TransitionMatcherFn[] {\n  const expressions: TransitionMatcherFn[] = [];\n  if (typeof transitionValue == 'string') {\n    (<string>transitionValue)\n        .split(/\\s*,\\s*/)\n        .forEach(str => parseInnerTransitionStr(str, expressions, errors));\n  } else {\n    expressions.push(<TransitionMatcherFn>transitionValue);\n  }\n  return expressions;\n}\n\nfunction parseInnerTransitionStr(\n    eventStr: string, expressions: TransitionMatcherFn[], errors: string[]) {\n  if (eventStr[0] == ':') {\n    const result = parseAnimationAlias(eventStr, errors);\n    if (typeof result == 'function') {\n      expressions.push(result);\n      return;\n    }\n    eventStr = result as string;\n  }\n\n  const match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (match == null || match.length < 4) {\n    errors.push(`The provided transition expression \"${eventStr}\" is not supported`);\n    return expressions;\n  }\n\n  const fromState = match[1];\n  const separator = match[2];\n  const toState = match[3];\n  expressions.push(makeLambdaFromStates(fromState, toState));\n\n  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(makeLambdaFromStates(toState, fromState));\n  }\n}\n\nfunction parseAnimationAlias(alias: string, errors: string[]): string|TransitionMatcherFn {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    case ':increment':\n      return (fromState: any, toState: any): boolean => parseFloat(toState) > parseFloat(fromState);\n    case ':decrement':\n      return (fromState: any, toState: any): boolean => parseFloat(toState) < parseFloat(fromState);\n    default:\n      errors.push(`The transition alias value \"${alias}\" is not supported`);\n      return '* => *';\n  }\n}\n\n// DO NOT REFACTOR ... keep the follow set instantiations\n// with the values intact (closure compiler for some reason\n// removes follow-up lines that add the values outside of\n// the constructor...\nconst TRUE_BOOLEAN_VALUES = new Set<string>(['true', '1']);\nconst FALSE_BOOLEAN_VALUES = new Set<string>(['false', '0']);\n\nfunction makeLambdaFromStates(lhs: string, rhs: string): TransitionMatcherFn {\n  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);\n  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);\n\n  return (fromState: any, toState: any): boolean => {\n    let lhsMatch = lhs == ANY_STATE || lhs == fromState;\n    let rhsMatch = rhs == ANY_STATE || rhs == toState;\n\n    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {\n      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);\n    }\n    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {\n      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);\n    }\n\n    return lhsMatch && rhsMatch;\n  };\n}\n"]}